# Lab1: Xv6 and Unix utilities

[TOC]

 ## 初识xv6

### xv6与Unix

**xv6 是 Unix 第六版 (v6) 的重新实现**，由Dennis Ritchie 和 Ken Thompson 设计。xv6 的设计大致遵循了v6的结构和风格，但使用了现代的RISC-V多处理器和ANSI C语言进行实现。它不仅模仿了Unix的内部设计，还保留了Unix操作系统的基本接口，这些接口由系统调用提供，为用户程序提供服务。

### 项目结构概览

在xv6项目中，Git仓库的不同分支通常对应着不同的实验或功能模块。每个分支可能包含某些特定的代码，用于完成与该分支相关的实验或功能。以下是这些分支可能的作用解释：

#### 分支说明

1. **`util`**: 这个分支是默认的分支，是用于实验“xv6 and Unix utilities”的分支。它包含了一些基本的用户空间工具和系统调用的实现。
2. **`cow`**: 这个分支可能涉及写时复制（Copy-On-Write）技术的实现。在操作系统中，写时复制是一种优化技术，用于在进程之间共享内存，同时在写操作时提供独立的副本。
3. **`debugging-demo`**: 这个分支可能是一个用于展示如何调试xv6系统的示例代码。它可能包含一些特定的调试工具或代码注释，用于帮助开发者理解和调试内核。
4. **`fs`**: 这个分支可能与文件系统相关，包含文件系统的实现或实验代码。在操作系统中，文件系统管理数据的存储和访问。
5. **`lock`**: 这个分支可能涉及锁机制的实现，用于多线程或多进程环境下的同步控制。锁可以防止竞争条件，确保多个进程或线程在共享资源时不会发生冲突。
6. **`mmap`**: 这个分支可能涉及内存映射（Memory Mapping）技术的实现。内存映射允许进程将文件或设备的内容映射到内存地址空间中。
7. **`net`**: 这个分支可能涉及网络相关的实现或实验代码。它可能包括网络栈的实现或简单的网络协议支持。
8. **`pgtbl`**: 这个分支可能涉及页表（Page Table）的实现或相关实验。页表是操作系统用于管理虚拟内存的一种数据结构。
9. **`riscv`**: 这个分支可能与RISC-V架构相关。RISC-V是一种开源的指令集架构，xv6在不同的实验中可能会支持不同的硬件架构。
10. **`syscall`**: 这个分支可能涉及系统调用的实现。系统调用是用户空间程序与内核交互的接口。
11. **`thread`**: 这个分支可能涉及线程的实现或相关实验。线程是轻量级的进程，可以共享同一个进程的资源。
12. **`traps`**: 这个分支可能涉及中断和异常处理机制的实现。在操作系统中，陷阱（Traps）通常指中断、异常或系统调用等事件的处理。

可以在不同的分支下运行xv6，不过每个分支可能包含不同的代码和功能集，具体取决于该分支的用途或实验内容。

#### 各个分支的运行方法：

1. **切换到目标分支**：首先，需要使用Git切换到想要探索或运行的分支。例如，假设切换到`cow`分支：

   ```bash
   git checkout cow
   ```

2. **编译并运行xv6**：在切换到目标分支后，可以使用以下命令编译并运行xv6：

   ```bash
   make qemu
   ```

每个分支可能会有不同的实验内容或功能实现，所以在不同分支下运行xv6可能会有不同的表现和输出。例如，在`thread`分支下，可能会测试线程相关的功能，而在`fs`分支下，可能会测试文件系统相关的功能。

### 操作系统接口

内核提供的一系列系统调用就是用户程序可见的操作系统接口，xv6 内核提供了 Unix 传统系统调用的一部分，它们是：

| 系统调用                  | 描述                               |
| ------------------------- | ---------------------------------- |
| fork()                    | 创建进程                           |
| exit()                    | 结束当前进程                       |
| wait()                    | 等待子进程结束                     |
| kill(pid)                 | 结束 pid 所指进程                  |
| getpid()                  | 获得当前进程 pid                   |
| sleep(n)                  | 睡眠 n 秒                          |
| exec(filename, *argv)     | 加载并执行一个文件                 |
| sbrk(n)                   | 为进程内存空间增加 n 字节          |
| open(filename, flags)     | 打开文件，flags 指定读/写模式      |
| read(fd, buf, n)          | 从文件中读 n 个字节到 buf          |
| write(fd, buf, n)         | 从 buf 中写 n 个字节到文件         |
| close(fd)                 | 关闭打开的 fd                      |
| dup(fd)                   | 复制 fd                            |
| pipe( p)                  | 创建管道， 并把读和写的 fd 返回到p |
| chdir(dirname)            | 改变当前目录                       |
| mkdir(dirname)            | 创建新的目录                       |
| mknod(name, major, minor) | 创建设备文件                       |
| fstat(fd)                 | 返回文件信息                       |
| link(f1, f2)              | 给 f1 创建一个新名字(f2)           |
| unlink(filename)          | 删除文件                           |

#### fork()

“一个 xv6 进程由两部分组成，一部分是用户内存空间（指令，数据，栈），另一部分是仅对内核可见的进程状态。xv6 提供了分时特性：它在可用 CPU 之间不断切换，决定哪一个等待中的进程被执行。当一个进程不在执行时，xv6 保存它的 CPU 寄存器，当他们再次被执行时恢复这些寄存器的值。内核将每个进程和一个 **pid** (process identifier) 关联起来。

一个进程可以通过系统调用 `fork` 来创建一个新的进程。`fork` 创建的新进程被称为**子进程**，子进程的内存内容同创建它的进程（父进程）一样。`fork` 函数在父进程、子进程中都返回（一次调用两次返回）。对于父进程它返回子进程的 pid，对于子进程它返回 0。”

```scss
+-----------+                      +-----------+
| Parent    |                      | Child     |
| Process   |                      | Process   |
|           |     fork() ----->    |           |
| (PID=100) |                      | (PID=101) |
+-----------+                      +-----------+
     |                                  |
     v                                  v
   (fork)                             (fork)
   returns                           returns
   child PID                         0
   (101)
```

##### 1. fork的实现机制

当一个进程调用 `fork` 时，操作系统内核会执行一系列步骤来创建一个新的进程，即子进程。操作系统在创建子进程的过程中，会复制父进程的进程控制块（PCB）和内存空间，使得子进程成为父进程的几乎完全复制品。然而，操作系统内核可以对子进程进行一些定制化处理，其中之一就是设置 `fork` 的返回值。

##### 2. fork返回值的设置

`fork` 的返回值是由操作系统内核在创建子进程时直接控制的。在以下过程中，操作系统设置了 `fork` 的返回值：

1. **父进程的返回值**：
   - 对于父进程，`fork` 的返回值是子进程的PID。操作系统在创建子进程时，知道新进程的PID，因此可以直接将这个值返回给父进程。
2. **子进程的返回值**：
   - 在创建子进程时，操作系统复制了父进程的内存和执行状态。但是，为了让子进程能够正确识别自身是新创建的子进程，而不是继续执行的父进程，操作系统将 `fork` 函数在子进程中的返回值设为 `0`。这是通过修改子进程的寄存器状态来实现的。

##### 3. 技术实现细节

在现代操作系统（如Linux）中，当 `fork` 被调用时，内核会执行如下操作：

- **复制父进程状态**：内核首先复制父进程的所有上下文，包括寄存器、内存映射、打开的文件描述符等。这使得子进程成为父进程的“克隆”。
- **设置子进程的返回值**：内核在完成复制后，会检查当前正在运行的进程（即刚创建的子进程）的上下文，并将寄存器中存储的 `fork` 函数的返回值设为 `0`。这是因为在C语言中，函数的返回值通常是通过寄存器传递的。
- **恢复执行**：当子进程开始运行时，它的程序计数器（PC）会指向 `fork` 调用之后的指令，但由于内核已经将其返回值设为 `0`，所以子进程的执行逻辑会根据 `fork` 返回 `0` 这个条件来执行与父进程不同的代码路径。

##### 4. 为什么这么做是安全且有效的？

操作系统内核有完全的控制权来决定如何管理和调度进程。通过直接操作子进程的执行上下文，内核可以轻松设置 `fork` 的返回值，这不仅是安全的，而且是操作系统正常工作的基本要求。因为内核在执行这些操作时，运行在特权模式下（内核态），它可以直接访问和修改进程的所有状态信息。

```c
int pid;
pid = fork();
if(pid > 0){
    printf("parent: child=%d\n", pid);
    pid = wait();
    printf("child %d is done\n", pid);
} else if(pid == 0){
    printf("child: exiting\n");
    exit();
} else {
    printf("fork error\n");
}
```

##### 5. 两种可能的输出顺序

1. **情况1：父进程先输出，然后子进程输出**

   - 假设父进程在子进程之前获得CPU时间片并执行 `printf("parent: child=%d\n", pid);`。此时父进程先输出 `parent: child=1234`。
   - 接下来，父进程调用 `wait()`，在此时父进程会被阻塞，直到子进程退出。
   - 子进程随后获得CPU时间片，执行 `printf("child: exiting\n");` 并调用 `exit()` 终止。
   - `wait()` 返回子进程的PID，父进程继续执行，输出 `child 1234 is done`。

   这种情况下的输出顺序为：

   ```bash
   parent: child=1234
   child: exiting
   child 1234 is done
   ```

2. **情况2：子进程先输出，然后父进程输出**

   - 假设子进程先获得CPU时间片并执行 `printf("child: exiting\n");`，然后调用 `exit()` 退出。
   - 子进程退出时，父进程的 `wait()` 被唤醒，返回子进程的PID。
   - 父进程随后执行 `printf("parent: child=%d\n", pid);` 和 `printf("child %d is done\n", pid);`。

   这种情况下的输出顺序为：

   ```bash
   child: exiting
   parent: child=1234
   child 1234 is done
   ```

#### exec()

`exec` 系统调用是 Unix 系统中一个非常重要的功能，用于在当前进程中加载并执行一个新的可执行文件。在调用 `exec` 后，当前进程的内存空间会被新加载的程序内容替换，进程从新程序的入口点开始执行，而不会返回到原来的程序。

##### `exec` 系统调用的工作原理

1. **加载新程序**：
   - 当 `exec` 被调用时，操作系统从指定的可执行文件中读取程序的内存镜像。这个文件必须符合操作系统支持的文件格式（如 ELF 文件格式）。
   - 文件格式中定义了哪些部分是代码段、数据段、以及程序的入口点（即从哪里开始执行）。
2. **替换内存空间**：
   - `exec` 会将当前进程的内存空间（包括代码段、数据段、堆栈等）用新加载的程序内容替换。这个过程会丢弃当前进程的旧内容，只保留新程序的内容。
   - 新的内存空间会根据可执行文件中的定义进行布局，指令和数据都被放置在适当的位置。
3. **开始执行新程序**：
   - 新程序开始执行时，是从可执行文件中指定的入口点（通常是 `main` 函数的起始地址）开始执行的。
   - 执行成功后，`exec` 不会返回到调用它的程序，而是继续执行新加载的程序。如果 `exec` 调用失败，通常是因为文件无法找到或文件格式不正确，此时 `exec` 会返回一个错误码。
4. **参数传递**：
   - `exec` 接受两个参数：一个是可执行文件的路径，另一个是一个字符串数组（通常称为 `argv`），它包含了传递给新程序的命令行参数。
   - 第一个参数 `argv[0]` 习惯上是程序的名字，但这并不是强制的。

##### 代码示例

以下代码展示了如何使用 `exec` 来执行一个新的程序：

```c
char *argv[3];
argv[0] = "echo";
argv[1] = "hello";
argv[2] = 0;  // 参数数组以 NULL 结束
exec("/bin/echo", argv);
printf("exec error\n");  // 如果 exec 失败，这行代码才会执行
```

在这个例子中，`exec` 会将当前进程替换为 `/bin/echo` 程序，并传递参数 `hello`。如果 `exec` 成功，`printf("exec error\n");` 这行代码永远不会执行，因为进程已经被新的程序替换了。

##### 为什么 `fork` 和 `exec` 是分开的？

在 Unix 系统中，`fork` 和 `exec` 是分开的系统调用，这是一个设计上的选择，带来了很多灵活性：

- **分离的灵活性**：通过将进程创建（`fork`）和程序加载（`exec`）分开，允许程序在创建子进程后进行一些额外的设置（如重定向文件描述符、设置环境变量等）后再加载新程序。
- **资源共享**：父进程可以在 `fork` 后对子进程进行配置，如共享打开的文件描述符，调整子进程的权限等，然后再调用 `exec` 来执行新程序。
- **管道和并行处理**：通过 `fork` 和 `exec` 的组合，可以很容易地创建进程管道和并行处理流，如通过 `fork` 创建多个进程，然后各自调用 `exec` 来运行不同的程序。

##### 在 `xv6` 中的使用

在 `xv6` 操作系统中，`exec` 的功能与传统 Unix 系统非常相似。`xv6` 的 `exec` 系统调用用于从文件系统中加载一个新的可执行文件，并替换当前进程的内存空间。`xv6` 中使用了 ELF 文件格式来定义程序的内存布局。Shell 程序通过 `exec` 来执行用户命令，这也是 Unix 系统中常见的行为。

#### shell

```c
int
main(void)
{
  static char buf[100];  // 用于存储用户输入的命令
  int fd;

  // 确保标准输入、输出和错误输出这三个文件描述符已打开。
  // 如果已经打开，就关闭多余的文件描述符。
  while((fd = open("console", O_RDWR)) >= 0){
    if(fd >= 3){  // 标准输入、输出、错误输出的文件描述符是0, 1, 2，超出这三个的就关闭
      close(fd);
      break;
    }
  }

  // 进入主循环，读取并执行用户输入的命令。
  while(getcmd(buf, sizeof(buf)) >= 0){
    // 处理 "cd" 命令，"cd" 命令必须由父进程执行
    if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
      // 将命令中的换行符去掉
      buf[strlen(buf)-1] = 0;  // chop \n
      // 改变当前工作目录为用户指定的目录
      if(chdir(buf+3) < 0)  // buf+3 跳过 "cd "，指向路径
        fprintf(2, "cannot cd %s\n", buf+3);  // 如果改变目录失败，打印错误信息
      continue;  // 继续读取下一条命令
    }
    // 创建子进程，子进程执行命令
    if(fork1() == 0)
      runcmd(parsecmd(buf));  // 解析并执行命令
    wait(0);  // 父进程等待子进程执行完毕
  }
  exit(0);  // 当退出主循环时，结束Shell进程
}
```

```c
// 确保标准输入、输出和错误输出这三个文件描述符已打开。
  // 如果已经打开，就关闭多余的文件描述符。
  while((fd = open("console", O_RDWR)) >= 0){
    if(fd >= 3){  // 标准输入、输出、错误输出的文件描述符是0, 1, 2，超出这三个的就关闭
      close(fd);
      break;
    }
  }
```

##### 文件描述符的管理

1. **文件描述符分配**：
   - 文件描述符是一个进程用来标识已打开文件的整数。每个进程都有自己独立的文件描述符表，通常从0开始递增分配。
   - 当你调用 `open()` 打开一个文件时，操作系统会在文件描述符表中找到最小的未使用的文件描述符，并将它分配给这个新打开的文件。
2. **标准文件描述符**：
   - 在大多数进程启动时，操作系统通常为其分配三个默认的文件描述符：
     - `0`：标准输入（stdin）
     - `1`：标准输出（stdout）
     - `2`：标准错误输出（stderr）
   - 这些文件描述符在进程开始运行时通常已经被打开，并指向控制台（终端），或者被重定向到其他设备或文件。
3. **为什么会返回不同的文件描述符**：
   - 如果一个进程刚启动时，这三个标准文件描述符（`0`、`1`、`2`）尚未被分配，那么第一次调用 `open("console", O_RDWR)` 会返回 `0`，因为这是文件描述符表中的第一个可用位置。
   - 第二次调用 `open("console", O_RDWR)` 会返回 `1`，第三次则返回 `2`。因为 `open` 总是返回当前最小的未使用文件描述符。
   - 如果这些文件描述符已经被占用（例如，它们已经被打开或者重定向），那么 `open` 会返回第一个未被使用的更大的文件描述符。

##### 代码执行的不同情境

- **情境1：进程启动时未打开标准文件描述符**： 如果进程刚启动且标准输入、输出、错误输出（`0`、`1`、`2`）未被打开，第一次 `open("console", O_RDWR)` 将返回 `0`，第二次返回 `1`，第三次返回 `2`。每次调用都会分配到下一个可用的文件描述符。
- **情境2：标准文件描述符已经打开**： 如果进程启动时标准文件描述符已经打开（例如被继承或已经被显式打开），`open("console", O_RDWR)` 将返回下一个未使用的文件描述符（通常是`3`或更大）。

#### cat()

```c
#include "kernel/types.h"   // 包含通用类型定义（如 int, uint, ushort 等）
#include "kernel/stat.h"    // 包含文件状态结构的定义（如 struct stat）
#include "kernel/fcntl.h"   // 包含文件控制选项（如 O_RDONLY, O_WRONLY 等）
#include "user/user.h"      // 包含用户程序所需的函数声明（如 read, write, open, close 等）

// 用于缓冲读取的数据
char buf[512];

// cat 函数：从文件描述符 fd 读取数据，并将其输出到标准输出
void
cat(int fd)
{
  int n;

  // 通过循环从文件描述符 fd 中读取数据，并写入标准输出
  while((n = read(fd, buf, sizeof(buf))) > 0) {
    // 如果写入过程中发生错误，输出错误信息并退出
    if (write(1, buf, n) != n) {  // write(1, ...) 写入标准输出（文件描述符1）
      fprintf(2, "cat: write error\n");  // 输出错误信息到标准错误（文件描述符2）
      exit(1);  // 以错误码 1 退出程序
    }
  }
  // 如果读取过程中发生错误，输出错误信息并退出
  if(n < 0){
    fprintf(2, "cat: read error\n");  // 输出错误信息到标准错误（文件描述符2）
    exit(1);  // 以错误码 1 退出程序
  }
}

// 主函数：处理命令行参数，并调用 cat 函数处理文件内容
int
main(int argc, char *argv[])
{
  int fd, i;

  // 如果没有提供任何命令行参数，则从标准输入读取并输出内容
  if(argc <= 1){
    cat(0);  // 0 表示标准输入，cat(0) 从标准输入读取内容并输出
    exit(0);  // 正常退出程序
  }

  // 如果提供了命令行参数（文件名），依次打开并处理这些文件
  for(i = 1; i < argc; i++){
    // 打开文件，使用只读模式（O_RDONLY）
    if((fd = open(argv[i], O_RDONLY)) < 0){
      // 如果打开文件失败，输出错误信息并退出
      fprintf(2, "cat: cannot open %s\n", argv[i]);  // 输出错误信息
      exit(1);  // 以错误码 1 退出程序
    }
    // 使用 cat 函数读取并输出文件内容
    cat(fd);
    // 处理完后关闭文件
    close(fd);
  }
  // 正常退出程序
  exit(0);
}
```

##### `main` 函数的参数

在C语言中，`main` 函数通常定义为：

```c
int main(int argc, char *argv[])
```

- **`argc`**：是一个整数，表示命令行中传递给程序的参数数量。`argc` 包括程序本身的名称，所以它至少为1。
- **`argv`**：是一个指向字符串数组的指针（即字符指针的指针）。每个元素都是一个字符串，代表命令行中的一个参数。`argv[0]` 是程序的名称，`argv[1]` 是第一个命令行参数，依此类推。

例如，如果你在命令行中运行程序：

```bash
./cat file1.txt file2.txt
```

- `argc` 将是 `3`，因为有三个参数（`./cat`, `file1.txt`, `file2.txt`）。

- ```bash
  argv
  ```

   是一个数组，内容为：

  - `argv[0]` 是 `"./cat"`
  - `argv[1]` 是 `"file1.txt"`
  - `argv[2]` 是 `"file2.txt"`

- `argv` 是一个指向字符串的指针数组。它的类型是 `char *argv[]` 或 `char **argv`，其中每个元素都是一个 `char *` 类型的字符串指针，指向以 `\0` 结尾的字符数组（即字符串）。

##### 输出重定向的处理机制

在 Unix 和类 Unix 系统中，命令的 **输出重定向** 是由 Shell 在启动命令之前处理的。当你运行 `cat file.txt 2> error.log` 时：

1. **Shell 的作用**：
   - Shell 解析命令并识别出 `2>` 这个重定向符号。
   - 在执行 `cat` 命令之前，Shell 会先打开 `error.log` 文件，并将标准错误输出（文件描述符 `2`）重定向到 `error.log` 文件。
   - 这样，`cat` 命令在运行时，任何写入到标准错误输出的内容都会被写入到 `error.log` 文件，而不是终端。
2. **`cat` 程序的作用**：
   - `cat` 程序的代码中使用了标准输出（文件描述符 `1`）和标准错误输出（文件描述符 `2`）进行输出。
   - 由于在执行 `cat` 之前，Shell 已经完成了重定向的设置，所以 `cat` 代码中的 `write(1, ...)` 和 `fprintf(2, ...)` 都会自动按照 Shell 的重定向设置将输出发送到正确的地方。

##### 总结

- **Shell 负责重定向**：输出重定向是在 Shell 层面完成的，因此 `cat` 的代码中不需要关心重定向的问题。`cat` 只是按照它的逻辑从文件或标准输入读取数据并输出到标准输出，并在出现错误时写入标准错误输出。实际的重定向由 Shell 在命令执行之前处理。
- **代码与重定向的关系**：`cat` 程序的代码只是单纯地使用标准文件描述符进行输入输出操作，至于这些文件描述符实际指向哪里（终端、文件或其他设备），由 Shell 根据重定向符来决定。

#### dup()

##### `dup` 的作用

`dup` 是 Unix 和类 Unix 操作系统中的一个系统调用，用于复制一个现有的文件描述符。它的主要作用是创建一个新的文件描述符，该文件描述符与原来的文件描述符指向同一个文件或设备，并共享同一个文件偏移量和文件状态。

##### `dup` 的具体行为

1. **创建新文件描述符**：
   - `dup(oldfd)` 创建一个新的文件描述符，这个新文件描述符指向与 `oldfd` 相同的文件或设备。新的文件描述符是当前进程中最小的可用文件描述符。
2. **文件偏移量共享**：
   - 新的文件描述符与原来的文件描述符共享同一个文件偏移量。这意味着，如果一个文件描述符进行读取或写入操作，文件偏移量将被更新，另一个文件描述符在接下来的读写操作中也会从更新后的偏移量开始。
3. **返回值**：
   - `dup` 的返回值是新的文件描述符，这个新的文件描述符与 `oldfd` 共享相同的文件描述符表项。

##### 示例解释

```c
fd = dup(1);       // 复制文件描述符1（标准输出），返回一个新的文件描述符fd
write(1, "hello", 6);  // 向标准输出写入 "hello"
write(fd, "world\n", 6); // 使用新文件描述符fd，继续向标准输出写入 "world\n"
```

- 共享文件偏移量：
  - 在上面的代码中，`dup(1)` 创建了一个新的文件描述符 `fd`，这个文件描述符指向同一个标准输出（文件描述符 `1`）。
  - 当执行 `write(1, "hello", 6)` 时，标准输出的文件偏移量被移动了6个字节。
  - 随后执行 `write(fd, "world\n", 6)` 时，由于 `fd` 共享与 `1` 相同的文件偏移量，所以它会从偏移量 `6` 处继续写入 "world\n"，最终在标准输出中得到 "helloworld" 这样的输出结果。

##### 文件描述符共享偏移量的影响

正如你提供的示例中提到的：

```c
if(fork() == 0) {
    write(1, "hello ", 6);
    exit();
} else {
    wait();
    write(1, "world\n", 6);
}
```

- `fork` 之后的文件描述符：
  - 当 `fork()` 创建一个新的子进程时，子进程继承了父进程的文件描述符表。因此，子进程和父进程共享同一个文件描述符表项，包括文件偏移量。
  - 子进程写入 "hello " 后，文件偏移量会更新。当父进程在 `wait()` 之后写入 "world\n" 时，会继续从子进程写入后的偏移量开始，结果是 "hello world"。

##### 通过 `dup` 实现重定向

- `dup` 可以用于实现输出重定向。例如，使用 `dup2(oldfd, newfd)` 可以将 `newfd` 复制为 `oldfd` 的副本，从而实现重定向：

  ```bash
  ls existing-file non-existing-file > tmp1 2>&1
  ```

  在这个命令中：

  - `2>&1` 表示将标准错误输出（文件描述符 `2`）重定向到标准输出（文件描述符 `1`）。通过使用 `dup2(1, 2)`，`2` 将成为 `1` 的副本，标准错误输出也会被写入 `tmp1` 文件中。

##### 总结

- **`dup` 创建新的文件描述符**：它返回一个与原文件描述符完全不同的新文件描述符，但它们指向相同的文件，并且共享文件偏移量。
- **共享文件偏移量**：这意味着对任一文件描述符的读写操作会影响另一个文件描述符的偏移量。
- **应用场景**：`dup` 和 `fork` 结合使用时，可以实现复杂的 I/O 重定向逻辑，比如将输出重定向到文件或者将错误输出和标准输出合并到同一个文件中。

##### 命令解释

```bash
ls existing-file non-existing-file > tmp1 2>&1
```

- **`ls`**：`ls` 是一个 Unix/Linux 命令，用于列出指定文件或目录的详细信息。如果文件或目录存在，`ls` 会输出其信息。如果文件或目录不存在，`ls` 会输出错误信息。
- **`existing-file` 和 `non-existing-file`**：这是两个参数：
  - `existing-file` 是一个实际存在的文件或目录。
  - `non-existing-file` 是一个不存在的文件或目录。
- **`>`**：这是输出重定向操作符。它将命令的标准输出（`stdout`）重定向到指定的文件。即将 `ls` 命令的输出写入到 `tmp1` 文件中。
- **`tmp1`**：`>` 后面的 `tmp1` 是重定向的目标文件。它将接收 `ls` 命令的标准输出内容。如果 `tmp1` 文件不存在，它会被创建；如果它已经存在，文件内容会被覆盖。
- **`2>&1`**：这是一种重定向标准错误输出（`stderr`）的语法。`2` 是标准错误输出的文件描述符，`1` 是标准输出的文件描述符。`>&` 表示重定向操作。
  - `2>&1` 的意思是将标准错误输出（`stderr`，文件描述符 `2`）重定向到标准输出（`stdout`，文件描述符 `1`）所指向的地方。因为标准输出已经被重定向到 `tmp1`，所以标准错误输出也会被重定向到 `tmp1` 文件。

##### 命令的完整效果

1. **执行 `ls existing-file non-existing-file`**：
   - 如果 `existing-file` 存在，`ls` 会输出其信息到标准输出。
   - 如果 `non-existing-file` 不存在，`ls` 会输出一条错误信息到标准错误输出。
2. **重定向标准输出到 `tmp1`**：
   - 标准输出被重定向到文件 `tmp1`，所以 `ls` 命令的输出（即 `existing-file` 的信息）会被写入 `tmp1`。
3. **重定向标准错误输出到 `tmp1`**：
   - 由于 `2>&1` 的重定向，标准错误输出（即 `non-existing-file` 不存在的错误信息）也会被写入 `tmp1` 文件。

##### 最终结果

- `tmp1`文件将包含两类信息：
  - `existing-file` 的正常输出信息。
  - `non-existing-file` 不存在的错误信息。

两者都被写入 `tmp1` 文件，因为标准输出和标准错误输出都被重定向到这个文件中。

##### 应用场景

这个命令非常有用，当你希望将命令的所有输出（包括正常输出和错误输出）都记录到一个文件中时，可以确保所有输出都集中在一个地方，以便于后续查看和分析。

### I/O和文件描述符

**文件描述符**是一个整数，它代表了一个进程可以读写的被内核管理的对象。进程可以通过多种方式获得一个文件描述符，如打开文件、目录、设备，或者创建一个管道（pipe），或者复制已经存在的文件描述符。简单起见，我们常常把文件描述符指向的对象称为“文件”。文件描述符的接口是对文件、管道、设备等的抽象，这种抽象使得它们看上去就是字节流。

每个进程都有一张表，而 xv6 内核就以文件描述符作为这张表的索引，所以每个进程都有一个从0开始的文件描述符空间。按照==惯例==，进程从文件描述符0读入（标准输入），从文件描述符1输出（标准输出），从文件描述符2输出错误（标准错误输出）。我们会看到 shell 正是利用了这种惯例来实现 I/O 重定向。shell 保证在任何时候都有3个打开的文件描述符（8007），他们是控制台（console）的默认文件描述符。

系统调用 `read` 和 `write` 从文件描述符所指的文件中读或者写 n 个字节。`read(fd, buf, n)` 从 `fd` 读最多 n 个字节（`fd` 可能没有 n 个字节），将它们拷贝到 `buf` 中，然后返回读出的字节数。每一个指向文件的文件描述符都和一个偏移关联。`read` 从当前文件偏移处读取数据，然后把偏移增加读出字节数。紧随其后的 `read` 会从新的起点开始读数据。当没有数据可读时，`read` 就会返回0，这就表示文件结束了。

`write(fd, buf, n)` 写 `buf` 中的 n 个字节到 `fd` 并且返回实际写出的字节数。如果返回值小于 n 那么只可能是发生了错误。就像 `read` 一样，`write` 也从当前文件的偏移处开始写，在写的过程中增加这个偏移。

下面这段程序（实际上就是 `cat` 的本质实现）将数据从标准输入复制到标准输出，如果遇到了错误，它会在标准错误输出输出一条信息。

```c
char buf[512];   // 用于存储读入数据的缓冲区
int n;

for(;;){  // 无限循环，直到读取结束或出现错误
    n = read(0, buf, sizeof buf);  // 从标准输入（文件描述符0）读取数据到缓冲区buf
    if(n == 0)  // 如果读到文件末尾（EOF），退出循环
        break;
    if(n < 0){  // 如果读取过程中发生错误，打印错误信息并退出
        fprintf(2, "read error\n");
        exit();
    }
    if(write(1, buf, n) != n){  // 将缓冲区buf中的数据写到标准输出（文件描述符1）
        fprintf(2, "write error\n");
        exit();
    }
}
```

这段代码中值得一提的是 `cat` 并不知道它是从文件、控制台或者管道中读取数据的。同样地 `cat` 也不知道它是写到文件、控制台或者别的什么地方。文件描述符的使用和一些惯例（如0是标准输入，1是标准输出）使得我们可以轻松实现 `cat`。

系统调用 `close` 会释放一个文件描述符，使得它未来可以被 `open`, `pipe`, `dup` 等调用重用。一个新分配的文件描述符永远都是当前进程的最小的未被使用的文件描述符。

文件描述符和 `fork` 的交叉使用使得 I/O 重定向能够轻易实现。`fork` 会复制父进程的文件描述符和内存，所以子进程和父进程的文件描述符一模一样。`exec` 会替换调用它的进程的内存但是会保留它的文件描述符表。这种行为使得 shell 可以这样实现重定向：`fork` 一个进程，重新打开指定文件的文件描述符，然后执行新的程序。下面是一个简化版的 shell 执行 `cat<input.txt` 的代码:

```c
char *argv[2];
argv[0] = "cat";
### argv[1] = 0;
if(fork() == 0) {
    close(0);
    open("input.txt", O_RDONLY);
    exec("cat", argv);
}
```

子进程关闭文件描述符0后，我们可以保证`open` 会使用0作为新打开的文件 `input.txt`的文件描述符（因为0是 `open` 执行时的最小可用文件描述符）。之后 `cat` 就会在标准输入指向 `input.txt` 的情况下运行。

xv6 的 shell 正是这样实现 I/O 重定位的（7930）。在 shell 的代码中，记得这时 `fork` 出了子进程，在子进程中 `runcmd` 会调用 `exec` 加载新的程序。现在你应该很清楚为何 `fork` 和 `exec` 是单独的两种系统调用了吧。这种区分使得 shell 可以在子进程执行指定程序之前对子进程进行修改。

### 管道

管道是一个小的内核缓冲区，它以文件描述符对的形式提供给进程，一个用于写操作，一个用于读操作。从管道的一端写的数据可以从管道的另一端读取。管道提供了一种进程间交互的方式。

接下来的示例代码运行了程序 `wc`，它的标准输出绑定到了一个管道的读端口。

```c
int p[2];          // 定义一个整型数组 p，用于存储管道的两个文件描述符
char *argv[2];     // 定义一个字符指针数组 argv，用于存储命令行参数

argv[0] = "wc";    // 将第一个命令行参数设置为 "wc"（word count 程序）
argv[1] = 0;       // 将 argv[1] 置为 NULL，表示命令行参数的结束

pipe(p);           // 创建一个管道，将读端描述符存储在 p[0]，写端描述符存储在 p[1]

if(fork() == 0) {  // 创建一个子进程。如果 fork() 返回 0，表示这是子进程
    close(0);           // 关闭子进程中的标准输入（文件描述符 0）
    dup(p[0]);          // 将管道的读端复制为文件描述符 0，即标准输入
    close(p[0]);        // 关闭管道的读端，因其已被复制到文件描述符 0
    close(p[1]);        // 关闭管道的写端（在子进程中不再需要）
    exec("/bin/wc", argv);  // 使用 exec 执行 "/bin/wc" 命令，参数为 argv
} else {             // 否则，这是父进程
    write(p[1], "hello world\n", 12);  // 向管道的写端写入 "hello world\n"（12 个字节）
    close(p[0]);    // 关闭管道的读端（在父进程中不再需要）
    close(p[1]);    // 关闭管道的写端，写操作完成
}
```

#### 详细解释

1. **创建管道 (`pipe(p)`)**：
   - `pipe(p)` 函数创建了一个管道，并将两个文件描述符存储在数组 `p` 中。`p[0]` 是管道的读端，`p[1]` 是管道的写端。
   - 管道是一种在进程间传递数据的方式。数据从写端进入管道，从读端取出。
2. **创建子进程 (`fork()`)**：
   - `fork()` 创建一个新进程（子进程），新进程是现有进程（父进程）的副本。`fork()` 在父进程中返回子进程的 PID，在子进程中返回 0。
   - 通过检查 `fork()` 的返回值，代码可以区分父进程和子进程。
3. **子进程的行为**：
   - 子进程中执行以下步骤：
     - 关闭标准输入（文件描述符 `0`），因为我们将用管道替换标准输入。
     - 使用 `dup(p[0])` 将管道的读端复制到文件描述符 `0`，这样管道的读端就成为了子进程的标准输入。
     - 关闭原来的管道读端和写端文件描述符，因为它们不再需要（读端已被复制为标准输入，写端在子进程中不会使用）。
     - 使用 `exec("/bin/wc", argv)` 执行 `wc` 命令。`exec` 用新的程序替换当前进程的内存，但保留文件描述符。此时，`wc` 命令的输入将来自标准输入（即管道的读端）。
4. **父进程的行为**：
   - 父进程负责向管道的写端写入数据：
     - `write(p[1], "hello world\n", 12)` 将字符串 `"hello world\n"` 写入管道。这些数据将被子进程（`wc` 命令）读取。
     - 关闭管道的读端和写端，表示写入操作已经完成。

#### 总体工作原理

- **管道传输数据**：父进程通过管道写入数据 `"hello world\n"`，子进程从管道的读端读取数据，并将其作为标准输入传递给 `wc` 命令。

- **执行 `wc`**：子进程中的 `wc` 命令会统计从管道中接收到的字符串 `"hello world\n"` 的字数、行数和字节数。由于管道的读端已经被重定向为标准输入，`wc` 命令可以像处理普通输入一样处理来自父进程的数据。

- **输出结果**：`wc` 命令的输出将显示在标准输出（通常是终端）上，显示结果为：

  ```
  复制代码
  1 2 12
  ```

  表示 `1` 行、`2` 个单词和 `12` 个字节。

#### 关键点总结

- **管道**：用于在父子进程之间传递数据。
- **文件描述符重定向**：使用 `dup` 和 `close` 重定向标准输入，使 `wc` 可以从管道读取数据。
- **进程间通信**：通过 `fork` 和管道实现父子进程的通信，子进程读取父进程传递的数据并执行命令。

#### 关键概念

1. **管道（Pipe）**：
   - 管道是用于进程间通信的机制，允许一个进程通过写端口将数据传递给另一个通过读端口读取数据的进程。
2. **阻塞（Blocking）`read`**：
   - 当进程尝试从管道读取数据时，如果管道中还没有数据，`read` 操作会阻塞（即进程会停下来等待），直到有数据可供读取或出现特定条件（如写端关闭）。

#### 解释逐步拆解

1. **`read` 会等待数据**：
   - 当你对一个管道执行 `read` 操作时，如果管道中暂时没有数据可供读取，`read` 操作不会立即返回，而是会阻塞，直到有数据被写入管道。
   - 这种设计允许进程之间同步数据传输，因为读取进程会等待写入进程提供数据。
2. **`read` 遇到 EOF（文件结束符）**：
   - 如果所有绑定在管道写端的文件描述符都被关闭，并且管道中没有未被读取的数据，那么管道的读端将接收到 EOF 信号。
   - 当 `read` 在这种情况下返回时，它会返回 `0`，这表示已经读到了文件结束（EOF）。这与读取文件时遇到文件末尾的行为相同。
3. **阻塞直到不能再有新数据**：
   - `read` 操作会一直阻塞，直到管道的写端关闭为止。只要有一个文件描述符指向管道的写端并保持打开状态，`read` 就会继续等待数据。
   - 这意味着如果你不关闭写端口，`read` 操作可能会无限期地等待，而不会返回 `0`，也不会结束读取操作。
4. **为什么要关闭写端口**：
   - 在使用管道和 `wc` 命令时（或者其他读取数据的命令），你需要在写完数据后关闭写端口。这一操作告诉 `read` 操作没有更多数据会到来，并促使它返回 EOF。
   - 如果你没有关闭写端口，`wc` 会永远等待更多数据的到来，永远不会看到 EOF 信号，因此不会结束读取操作或输出结果。

#### 举例说明

在你之前提供的代码中：

```c
write(p[1], "hello world\n", 12);
close(p[1]);  // 关闭写端口
```

- 在父进程中，`write` 操作将 `"hello world\n"` 写入管道。这时子进程中的 `wc` 正在等待数据。
- 当写操作完成后，父进程关闭了管道的写端口。
- 由于写端口被关闭，子进程中的 `wc` 看到管道中的数据全部被读取完毕，并且读端收到了 EOF 信号。于是，`wc` 停止读取并输出结果。

pipe 可能看上去和临时文件没有什么两样：命令

```
echo hello world | wc
```

可以用无管道的方式实现：

```
echo hello world > /tmp/xyz; wc < /tmp/xyz
```

但管道和临时文件起码有三个关键的不同点。首先，管道会进行自我清扫，如果是 shell 重定向的话，我们必须要在任务完成后删除 `/tmp/xyz`。第二，管道可以传输任意长度的数据。第三，管道允许同步：两个进程可以使用一对管道来进行二者之间的信息传递，每一个读操作都阻塞调用进程，直到另一个进程用 `write` 完成数据的发送。

##### 1. **`echo hello world`**：

- `echo` 是一个命令，用于在终端输出文本。

- `echo hello world` 会在终端打印出 `hello world`，然后换行。

- 例如，如果你在终端中运行 

  ```
  echo hello world
  ```

  ，结果是：

  ```
  复制代码
  hello world
  ```

##### 2. **`|`（管道）**：

- `|` 是一个管道操作符，用于将前一个命令的输出作为下一个命令的输入。
- 在这个命令中，`echo hello world` 的输出不会直接显示在终端上，而是通过管道传递给下一个命令 `wc`。

##### 3. **`wc`**：

- `wc` 是一个命令，用于统计文本中的字数、行数和字节数。
- 默认情况下，`wc` 会输出三列数据：行数、单词数、字节数。
- `wc` 接收到来自 `echo` 的输入后，会对这段输入文本进行统计。

##### 命令的完整工作原理

1. **`echo hello world` 的输出**：

   - `echo hello world` 生成的文本是 `hello world`，并附带一个换行符 `\n`。
   - 该输出通过管道传递给 `wc`。

2. **`wc` 统计输入的内容**：

   - ```
     wc
     ```

      接收到文本 

     ```
     hello world\n
     ```

     ，然后统计以下信息：

     - **行数**：`1` 行（因为有一个换行符）。
     - **单词数**：`2` 个单词（`hello` 和 `world`）。
     - **字节数**：`12` 个字节（`hello` 是 5 个字节，`world` 是 5 个字节，加上换行符 `\n` 和一个空格，共 12 个字节）。

3. **最终输出**：

   - ```
     wc
     ```

      命令将结果输出到终端，通常是这样的格式：

     ```
     复制代码
     1 2 12
     ```

   - 这表示：1 行、2 个单词、12 个字节。

##### 总结

- **`echo hello world`**：输出字符串 `hello world`。
- **`|`（管道）**：将 `echo` 的输出传递给 `wc` 命令。
- **`wc`**：统计并输出行数、单词数和字节数。

最终结果显示的是 `hello world` 这段文本的行数、单词数和字节数，分别为 `1 2 12`。

### 文件系统

xv6 文件系统提供文件和目录，文件就是一个简单的字节数组，而目录包含指向文件和其他目录的引用。xv6 把目录实现为一种特殊的文件。目录是一棵树，它的根节点是一个特殊的目录 `root`。`/a/b/c` 指向一个在目录 `b` 中的文件 `c`，而 b 本身又是在目录 `a` 中的，`a` 又是处在 `root` 目录下的。不从 `/` 开始的目录表示的是相对调用进程当前目录的目录，调用进程的当前目录可以通过 `chdir` 这个系统调用进行改变。下面的这些代码都打开同一个文件（假设所有涉及到的目录都是存在的）。

```c
chdir("/a");
chdir("b");
open("c", O_RDONLY);

open("/a/b/c", O_RDONLY);
```

第一个代码段将当前目录切换到 `/a/b`; 第二个代码片段则对当前目录不做任何改变。

有很多的系统调用可以创建一个新的文件或者目录：`mkdir` 创建一个新的目录，`open` 加上 `O_CREATE` 标志打开一个新的文件，`mknod` 创建一个新的设备文件。下面这个例子说明了这3种调用：

```c
mkdir("/dir");
fd = open("/dir/file", O_CREATE|O_WRONLY);
close(fd);
mknod("/console", 1, 1);
```

`mknod` 在文件系统中创建一个文件，但是这个文件没有任何内容。相反，这个文件的元信息标志它是一个设备文件，并且记录主设备号和辅设备号（`mknod` 的两个参数），这两个设备号唯一确定一个内核设备。当一个进程之后打开这个文件的时候，内核将读、写的系统调用转发到内核设备的实现上，而不是传递给文件系统。

`fstat` 可以获取一个文件描述符指向的文件的信息。它填充一个名为 `stat` 的结构体，它在 `stat.h` 中定义为：

```C
#define T_DIR  1
#define T_FILE 2
#define T_DEV  3
// Directory
// File
// Device
     struct stat {
       short type;  // Type of file
       int dev;     // File system’s disk device
       uint ino;    // Inode number
       short nlink; // Number of links to file
       uint size;   // Size of file in bytes
};
```

文件名和这个文件本身是有很大的区别。同一个文件（称为 `inode`）可能有多个名字，称为**连接** (`links`)。系统调用 `link` 创建另一个文件系统的名称，它指向同一个 `inode`。下面的代码创建了一个既叫做 `a` 又叫做 `b` 的新文件。

```C
open("a", O_CREATE|O_WRONGLY);
link("a", "b");
```

读写 `a` 就相当于读写 `b`。每一个 inode 都由一个唯一的 `inode 号` 直接确定。在上面这段代码中，我们可以通过 `fstat` 知道 `a` 和 `b` 都指向同样的内容：`a` 和 `b` 都会返回同样的 inode 号（`ino`），并且 `nlink` 数会设置为2。

系统调用 `unlink` 从文件系统移除一个文件名。一个文件的 inode 和磁盘空间只有当它的链接数变为 0 的时候才会被清空，也就是没有一个文件再指向它。因此在上面的代码最后加上

`unlink("a")`，

我们同样可以通过 `b` 访问到它。另外，

```C
fd = open("/tmp/xyz", O_CREATE|O_RDWR);
unlink("/tmp/xyz");
```

是创建一个临时 inode 的最佳方式，这个 inode 会在进程关闭 `fd` 或者退出的时候被清空。

xv6 关于文件系统的操作都被实现为用户程序，诸如 `mkdir`，`ln`，`rm` 等等。这种设计允许任何人都可以通过用户命令拓展 shell 。现在看起来这种设计是很显然的，但是 Unix 时代的其他系统的设计都将这样的命令内置在了 shell 中，而 shell 又是内置在内核中的。

有一个例外，那就是 `cd`，它是在 shell 中实现的（8016）。`cd` 必须改变 shell 自身的当前工作目录。如果 `cd` 作为一个普通命令执行，那么 shell 就会 `fork` 一个子进程，而子进程会运行 `cd`，`cd` 只会改变*子进程*的当前工作目录。父进程的工作目录保持原样。

## 实验内容

### 1. Boot xv6(easy)

